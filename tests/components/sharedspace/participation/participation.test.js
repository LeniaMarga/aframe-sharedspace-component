const EventTarget = require('event-target-shim');
const GuestList = require(
  '../../../../src/components/sharedspace/participation/guest-list'
).GuestList;

suite.only('Participation', () => {
  const inject = require(
    'inject-loader!../../../../src/components/sharedspace/participation'
  );
  let Participation;
  let participation;

  let GuestListSpy, guestlist;
  let fakeRTCInterfaceCons, fakeRTCInterface;

  const nowFunction = Date.now;
  const now = 2;
  const stream = new MediaStream();

  setup(() => {
    Date.now = () => now;

    GuestListSpy = sinon.spy(GuestList);
    GuestListSpy.copy = GuestList.copy;
    GuestListSpy.serialize = GuestList.serialize;
    GuestListSpy.deserialize = GuestList.deserialize;
    GuestListSpy.transformationCost = GuestList.transformationCost;

    fakeRTCInterfaceCons = class extends EventTarget {
      constructor(room, { id }) {
        super();
        this._connections = {};
        this._id = id;
        fakeRTCInterface = this;
      }

      connect() {
        this._connected = true;
        return Promise.resolve();
      }

      isConnected(id) {
        return this._connections[id];
      }

      get me() {
        return this._connected && (this._id || 'randomId');
      }

      fakeConnection(id) {
        this._connections[id] = true;
        this.emit('connect', { id });
      }

      emit(type, detail) {
        const event = new CustomEvent(type, { detail });
        fakeRTCInterface.dispatchEvent(event);
      }

      broadcast() {}

      send() {}
    };
    sinon.spy(fakeRTCInterfaceCons.prototype, 'connect');
    sinon.spy(fakeRTCInterfaceCons.prototype, 'broadcast');
    sinon.spy(fakeRTCInterfaceCons.prototype, 'send');
    fakeRTCInterfaceCons = sinon.spy(fakeRTCInterfaceCons);

    Participation = inject({
      './guest-list': { GuestList: GuestListSpy },
      '../rtc-interface': { RTCInterface: fakeRTCInterfaceCons }
    }).Participation;

    participation =
      new Participation('testRoom', { stream, provider: 'test.com' });
  });

  teardown(() => {
    Date.now = nowFunction;
  });

  suite('constructor', () => {

    test('constructs a RTCInterface object without connecting', () => {
      assert.isTrue(fakeRTCInterfaceCons.calledWith('testRoom', {
        id: undefined,
        stream,
        signaling: 'test.com'
      }));
      assert.isTrue(fakeRTCInterface.connect.notCalled);
    });

  });

  suite('me property', () => {

    test('returns unknown before connecting', () => {
      assert.isUndefined(participation.me);
    });

    test('after connecting, returns the id passed in the constructor', () => {
      participation = new Participation('testRoom', {
        id: 'myId',
        stream,
        provider: 'test.com'
      });
      return participation.connect()
      .then(() => {
        assert.equal(participation.me, 'myId');
      });
    });

    test('after connecting, returns an autogenerated id if not passed in the constructor', () => {
      return participation.connect()
      .then(() => {
        assert.equal(participation.me, 'randomId');
      });
    });

  });

  suite('connect method', () => {

    test('instantiates a guest list with the local user as participant', () => {
      return participation.connect()
      .then(() => {
        assert.isTrue(GuestListSpy.calledOnce);
        assert.isTrue(GuestListSpy.calledWith(now, ['randomId']));
      });
    });

    test('emits connect event', done => {
      participation.addEventListener('connected', ({ detail }) => {
        assert.equal(detail.me, 'randomId');
        done();
      });
      participation.connect();
    });

  });

  suite('after connect', () => {

    setup(() => {
      return participation.connect()
      .then(() => {
        guestlist = GuestListSpy.returnValues[0];
      });
    });

    suite('send method', () => {
      const message = {};

      test('broadcasts message when passing * as target', () => {
        participation.send('*', message);
        assert.isTrue(fakeRTCInterface.broadcast.calledOnce);
        assert.isTrue(fakeRTCInterface.broadcast.calledWith({
          type: 'content',
          content: message
        }));
      });

      test('sends a message when passing an id as target', () => {
        participation.send('id1', message);
        assert.isTrue(fakeRTCInterface.send.calledOnce);
        assert.isTrue(fakeRTCInterface.send.calledWith('id1', {
          type: 'content',
          content: message
        }));
      });

    });

    function becomeHost() {
      let fulfil;

      participation.addEventListener('upgrade', function onUpgrade({ detail }) {
        participation.removeEventListener('upgrade', onUpgrade);
        assert.equal(detail.role, 'host');
        fulfil();
      });

      return new Promise(f => {
        fulfil = f;
        fakeRTCInterface.emit('message', {
          type: 'list',
          timestamp: now + 1,
          list: ['remoteId', 'randomId']
        });
      });
    }

    function becomeGuest() {
      let fulfil;

      participation.addEventListener('upgrade', function onUpgrade({ detail }) {
        participation.removeEventListener('upgrade', onUpgrade);
        assert.equal(detail.role, 'guest');
        fulfil();
      });

      return new Promise(f => {
        fulfil = f;
        fakeRTCInterface.emit('message', {
          type: 'list',
          timestamp: now - 1,
          list: ['remoteId', 'randomId']
        });
      });
    }

    suite.only('if role unknonw', () => {

      suite('on RTC connect', () => {

        test('updates and broadcast list', () => {
          participation.addEventListener('enterparticipant', () => {
            assert.isTrue(false, 'Should not advertise changes.');
          });
          fakeRTCInterface.emit('connect', { id: 'remoteId' });
          assert.isTrue(fakeRTCInterface.broadcast.calledOnce);
          assert.isTrue(fakeRTCInterface.broadcast.calledWith({
            type: 'list',
            timestamp: now,
            list: ['randomId', 'remoteId']
          }));
        });

      });

      suite('on RTC stream', () => {

        setup(() => {
          fakeRTCInterface.emit('stream', { id: 'remoteId', stream });
        });

        test('holds the event until confirming presence after becoming host', done => {
          participation.addEventListener('participantstream', ({ detail }) => {
            assert.equal(detail.id, 'remoteId');
            assert.equal(detail.stream, stream);
            done();
          });
          fakeRTCInterface.fakeConnection('remoteId');
          becomeHost();
        });

        test('holds the event until confirming presence after becoming guest', done => {
          participation.addEventListener('participantstream', ({ detail }) => {
            assert.equal(detail.id, 'remoteId');
            assert.equal(detail.stream, stream);
            done();
          });
          fakeRTCInterface.fakeConnection('remoteId');
          becomeGuest();
        });

      });

      suite('on RTC message', () => {

        test('becomes host after reciving a more recent guest list', () => {
          becomeHost();
        });

        test('becomes guest after reciving an older guest list', () => {
          becomeGuest();
        });

        suite('content messages', () => {

          setup(() => {
            fakeRTCInterface.emit('message', {
              from: 'remoteId',
              type: 'content',
              content: 'test'
            });
          });

          test('holds the event until confirming presence after becoming host', done => {
            participation.addEventListener('participantmessage', ({ detail }) => {
              assert.equal(detail.id, 'remoteId');
              assert.equal(detail.message, 'test');
              done();
            });
            fakeRTCInterface.fakeConnection('remoteId');
            becomeHost();
          });

          test('holds the event until confirming presence after becoming guest', done => {
            participation.addEventListener('participantmessage', ({ detail }) => {
              assert.equal(detail.id, 'remoteId');
              assert.equal(detail.message, 'test');
              done();
            });
            fakeRTCInterface.fakeConnection('remoteId');
            becomeGuest();
          });

        });

      });

      suite('on RTC close', () => {

        test('updates and broadcast list', () => {
          participation.addEventListener('exitparticipant', () => {
            assert.isTrue(false, 'Should not advertise changes.');
          });
          fakeRTCInterface.emit('close', { id: 'remoteId' });
          assert.isTrue(fakeRTCInterface.broadcast.calledOnce);
          assert.isTrue(fakeRTCInterface.broadcast.calledWith({
            type: 'list',
            timestamp: now,
            list: ['randomId']
          }));
        });

      });

    });

  });

})
